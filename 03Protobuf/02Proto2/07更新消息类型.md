## 更新消息类型

如果现有的消息类型不再满足您的所有需要（例如，您希望消息格式有一个额外的字段），但是您仍然希望使用用旧格式创建的代码，不要担心！在不破坏任何现有代码的情况下更新消息类型非常简单。记住以下规则：

- 不要更改任何现有字段的字段号。
- 新增的字段应该是`optional`或`repeated`。这意味着使用“旧”消息格式的代码序列化的任何消息都可以由新生成的代码进行解析，因为它们不会缺少任何必需的元素。您应该为这些元素设置合理的默认值，以便新代码可以正确地与旧代码生成的消息交互。类似地，由新代码创建的消息也可以由旧代码解析：旧二进制文件在解析时忽略新字段。但是，未知字段不会被丢弃，并且如果消息稍后被序列化，则未知字段也会随之被序列化–因此，如果消息传递给新代码，则新字段仍然可用。
- 非`required`字段可以转换为扩展（下面会有解释），反之亦然，只要类型和字段号保持不变。
- `int32`、`uint32`、`int64`、`uint64`和`bool`都是兼容的—这意味着您可以将字段从一种类型更改为另一种类型，而不会破坏向前或向后的兼容性。如果从不适合于相应类型的线中解析一个数，则将获得与在C++中将该数转换为该类型的相同效果（例如，如果64位数字被读取为一个`int32`，则它将被截断到32位）。
- `sint32`和`sint64`彼此兼容，但与其他整数类型不兼容。
- 只要`bytes`是有效的`UTF-8`，`string`和`bytes`就可以兼容。
- 如果`bytes`包含消息的编码版本，则嵌入的消息与`bytes`兼容。
- `fixed32`与`sfixed32`兼容，`fixed64`与`sfixed64`兼容。
- 对于`string`、`bytes`和消息字段，`optional`与`repeated`兼容。给定`repeated`字段的序列化数据作为输入，如果该字段是基元类型字段，则期望该字段为`optional`字段的客户端将获取最后一个输入值；如果该字段是消息类型字段，则合并所有输入元素。请注意，对于数值类型（包括`bool`和`enum`），这通常是不安全的。数字类型的`repeated`字段可以按压缩格式序列化，当需要`optional`字段时，将无法正确解析压缩格式。
- 更改默认值通常是可以的，只要您记住默认值从不通过导线发送。因此，如果一个程序接收到一条没有设置特定字段的消息，该程序将看到在该程序的协议版本中定义的默认值。它不会看到发送方代码中定义的默认值。
- `enum`在`wire`格式方面与`int32`、`uint32`、`int64`和`uint64`兼容（强转时值将被截断）,但是请注意，当消息被反序列化时，客户端代码可能会对它们进行不同的处理。值得注意的是，在反序列化消息时，将丢弃无法识别的枚举值，这会导致这个字段的`has..()`方法返回`false`、`getter()`方法返回枚举中定义的第一个值，或默认值(如果指定了默认值的话)。对于重复的枚举字段，任何无法识别的值都将从列表中除去。但是，整数字段将始终保留其值。因此，在将整数升级为枚举时，您需要非常小心，以在线路上接收超出界限的枚举值。
- 在当前的java和C++实现中，当未识别的枚举值被剥离时，它们与其他未知字段一起存储。请注意，如果此数据被序列化，然后由识别这些值的客户端重新分析，则这可能会导致奇怪的行为。对于`optional`字段，即使在反序列化原始消息后写入了新值，识别旧值的客户端仍将读取旧值。在`repeated`字段的情况下，旧值将出现在任何已识别的值和新添加的值之后，这意味着不会保留顺序。
- 将单个`optional`值更改为新值的成员是安全的，并且与二进制兼容。如果您确定没有代码一次设置多个字段，那么将多个可选字段移到其中一个新字段中可能是安全的。将任何字段移到现有字段中都不安全。
- 在`map<K，V>`和相应的`repeated message`字段之间更改字段是二进制兼容的（有关消息布局和其他限制，请参阅下面的map）。但是，更改的安全性取决于应用程序：当对消息进行反序列化和重新序列化时，使用重复字段定义的客户端将产生语义相同的结果；但是，使用映射字段定义的客户端可能会对条目重新排序，并删除具有重复键的条目。