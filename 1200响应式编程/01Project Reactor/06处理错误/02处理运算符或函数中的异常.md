# 处理运算符或函数中的异常

&emsp;&emsp;通常，所有运算符本身都可能包含可能触发异常或调用可能同样失败的用户定义回调的代码，因此它们都包含某种形式的错误处理。

&emsp;&emsp;根据经验，未经检查的异常总是通过 `onError` 传播。例如，在 map 函数中抛出 `RuntimeException` 会转换为 `onError` 事件，如以下代码所示：

```java
Flux.just("foo")
    .map(s -> { throw new IllegalArgumentException(s); })
    .subscribe(v -> System.out.println("GOT VALUE"),
               e -> System.out.println("ERROR: " + e));
```

&emsp;&emsp;前面的代码打印出以下内容：

```bash
ERROR: java.lang.IllegalArgumentException: foo
```

> 您可以通过使用挂钩在将异常传递给 `onError` 之前对其进行调整。

&emsp;&emsp;然而，Reactor 定义了一组总是被认为是致命的异常（例如 `OutOfMemoryError`）。请参阅 `Exceptions.throwIfFatal` 方法。这些错误意味着 Reactor 无法继续运行并被抛出而不是传播。

> 在内部，还有一些情况仍然无法传播未经检查的异常（最明显的是在订阅和请求阶段），因为并发竞争可能导致双重 `onError` 或 `onComplete` 条件。当这些竞争发生时，无法传播的错误将被“丢弃”。这些情况仍然可以通过使用可定制的挂钩在某种程度上进行管理。请参阅[丢弃钩子](https://projectreactor.io/docs/core/release/reference/#hooks-dropping)。

&emsp;&emsp;你可能会问：“检查异常呢？”

&emsp;&emsp;例如，如果您需要调用一些声明它抛出异常的方法，您仍然必须在 `try-catch` 块中处理这些异常。不过，您有多种选择：

- 捕获异常并从中恢复。序列正常继续。
- 捕获异常，将其包装成未经检查的异常(运行时异常)，然后将其抛出（中断序列）。 `Exceptions` 实用程序类可以帮助您解决这个问题（我们接下来会讲到）。
- 如果您需要返回一个 `Flux`（例如，您在一个 `flatMap` 中），请将异常包装在一个产生错误的 `Flux` 中，如下所示：`return Flux.error(checkedException)`。 （序列也终止。）

&emsp;&emsp;`Reactor` 有一个 `Exceptions` 实用程序类，您可以使用它来确保仅在检查异常时才包装异常：

- 