# 错误处理运算符

&emsp;&emsp;您可能熟悉在 try-catch 块中处理异常的几种方法。最值得注意的是，这些包括以下内容：

- 捕获并返回静态默认值。
- 使用回退方法捕获并执行替代路径。
- 捕获并动态计算回退值。
- 捕获、包装到BusinessException，然后重新抛出。
- 捕获、记录特定于错误的消息，然后重新抛出。
- 使用finally块清理资源或Java7“trywithresource”构造。

&emsp;&emsp;所有这些在 Reactor 中都以错误处理运算符的形式存在。在研究这些运算符之前，我们首先要在反应链和 try-catch 块之间建立一个并行关系。

&emsp;&emsp;订阅时，链末尾的 onError 回调类似于一个 catch 块。在那里，如果抛出异常，执行将跳到catch ，如以下示例所示：

```java
Flux<String> s = Flux.range(1, 10)
    .map(v -> doSomethingDangerous(v))  // 1 执行可以抛出异常的转换。
    .map(v -> doSecondTransform(v));  // 2 如果一切顺利，将执行第二次转换。(显然前面不会顺序)
s.subscribe(value -> System.out.println("RECEIVED " + value), // 3 每个成功转换的值都被打印出来。
            error -> System.err.println("CAUGHT " + error)  // 4 如果出现错误，序列将终止并显示一条错误消息。
);
```

&emsp;&emsp;前面的示例在概念上类似于以下 try-catch 块：

```java
try {
    for (int i = 1; i < 11; i++) {
        String v1 = doSomethingDangerous(i);  // 1 如果这里抛出异常……
        String v2 = doSecondTransform(v1);  // 2 …循环的其余部分被跳过…
        System.out.println("RECEIVED " + v2);
    }
} catch (Throwable t) {
    System.err.println("CAUGHT " + t);  // 3 …​ and the execution goes straight to here.

}
```

&emsp;&emsp;现在我们已经建立了一个并行，我们可以看看不同的错误处理案例和它们的等效运算符。

---

### 静态回退值

&emsp;&emsp;“捕捉并返回静态默认值”的等价物是 onErrorReturn。以下示例显示了如何使用它：

```java
try {
  return doSomethingDangerous(10);
}
catch (Throwable error) {
  return "RECOVERED";
}
```

&emsp;&emsp;以下示例显示了 Reactor 等效项：

```java
Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn("RECOVERED");
```

&emsp;&emsp;您还可以选择对异常应用谓词来决定是否恢复，如以下示例所示：

```java
Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn(e -> e.getMessage().equals("boom10"), "recovered10");  // 1 仅在异常消息为“boom10”时恢复
```

---

### 捕获并吞下错误

&emsp;&emsp;如果您甚至不想用回退值替换异常，而是忽略它并只传播到目前为止已经生成的元素，那么您实际上想要的是用 `onComplete` 信号替换 `onError` 信号。这可以通过 `onErrorComplete` 运算符来完成：

```java
Flux.just(10,20,30)
    .map(this::doSomethingDangerousOn30)
    .onErrorComplete();  // 1 通过将 onError 变成 onComplete 来恢复
```

&emsp;&emsp;与 `onErrorReturn` 一样，`onErrorComplete` 有一些变体，可以让您根据异常的类或 Predicate 过滤要回退的异常。

---

### 回退方法

&emsp;&emsp;如果您想要多个默认值并且您有另一种（更安全的）处理数据的方式，您可以使用 `onErrorResume`。这相当于“使用回退方法捕获并执行替代路径”。

&emsp;&emsp;例如，如果您的标称进程正在从外部和不可靠的服务中获取数据，但您还保留了相同数据的本地缓存，这些数据可能有点过时但更可靠，您可以执行以下操作：

```java
String v1;
try {
  v1 = callExternalService("key1");
}
catch (Throwable error) {
  v1 = getFromCache("key1");
}

String v2;
try {
  v2 = callExternalService("key2");
}
catch (Throwable error) {
  v2 = getFromCache("key2");
}
```

&emsp;&emsp;以下示例显示了 Reactor 等效项：

```java
Flux.just("key1", "key2")
    .flatMap(k -> callExternalService(k)  // 1 对于每个键，异步调用外部服务。
        .onErrorResume(e -> getFromCache(k)) // 2 如果外部服务调用失败，则回退到该键的缓存。请注意，无论源错误 e 是什么，我们总是应用相同的回退。
    );
```

&emsp;&emsp;与 `onErrorReturn` 一样，`onErrorResume` 有一些变体，可以让您根据异常的类或 `Predicate` 过滤要回退的异常。它采用 `Function` 的事实还允许您根据遇到的错误选择不同的回退序列来切换。以下示例显示了如何执行此操作：

```java
Flux.just("timeout1", "unknown", "key2")
    .flatMap(k -> callExternalService(k)
        .onErrorResume(error -> { // 1 该功能允许动态选择如何继续
            if (error instanceof TimeoutException) // 2 如果源超时，则命中本地缓存。
                return getFromCache(k);
            else if (error instanceof UnknownKeyException)  // 3 如果消息来源说密钥未知，请创建一个新条目。
                return registerNewEntry(k, "DEFAULT");
            else
                return Flux.error(error); // 4 在所有其他情况下，“重新投掷”。
        })
    );
```

---

### 动态回退值

&emsp;&emsp;即使您没有其他（更安全的）方法来处理您的数据，您也可能希望根据收到的异常计算回退值。这相当于“捕获并动态计算回退值”。

&emsp;&emsp;例如，如果您的返回类型 (`MyWrapper`) 有一个专用于保存异常的变体（想想 `Future.complete(T success)` 与 `Future.completeExceptionally(Throwable error)`），您可以实例化错误保存变体并传递异常。

&emsp;&emsp;命令式示例如下所示：

```java
try {
  Value v = erroringMethod();
  return MyWrapper.fromValue(v);
}
catch (Throwable error) {
  return MyWrapper.fromError(error);
}
```

您可以通过使用 `onErrorResume` 和少量样板文件，以与回退方法解决方案相同的方式响应式地执行此操作，如下所示：

```java
erroringFlux.onErrorResume(error -> Mono.just(  // 1
        MyWrapper.fromError(error)  // 2
));
```

> 1 由于您期望错误的 `MyWrapper` 表示，因此您需要为 `onErrorResume` 获取 `Mono<MyWrapper>`。我们为此使用 Mono.just()
>
> 2 我们需要计算异常的值。在这里，我们通过使用相关的 `MyWrapper` 工厂方法包装异常来实现这一点。

---

### 捕捉并重新抛出

