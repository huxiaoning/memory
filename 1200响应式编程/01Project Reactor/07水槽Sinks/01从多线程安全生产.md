# 使用 `Sinks.One` 和 `Sinks.Many` 从多线程安全生产

&emsp;&emsp;`reactor-core` 公开的 `Sinks` 的默认风格确保多线程使用被检测到，并且从下游订阅者的角度来看不会导致规范违规或未定义的行为。使用`tryEmit*API`时，并行调用会快速失败。使用 `emit* API` 时，提供的 `EmissionFailureHandler` 可能允许重试争用（例如，忙循环），否则接收器将因错误而终止。

&emsp;&emsp;这是对 `Processor.onNext` 的改进，`Processor.onNext` 必须在外部同步，否则从下游订阅者的角度来看会导致未定义的行为。

> &emsp;&emsp;处理器是一种特殊的发布者，也是订阅者。它们最初旨在作为中间步骤的可能表示，然后可以在 `Reactive Streams` 实现之间共享。然而，在 `Reactor` 中，这些步骤由 `Publisher` 运算符表示。
>
> &emsp;&emsp;第一次遇到 `Processor` 时的一个常见错误是直接从 `Subscriber` 接口调用公开的 `onNext`、`onComplete` 和 `onError` 方法。
>
> &emsp;&emsp;应谨慎进行此类手动调用，尤其是关于响应式流规范的外部同步调用。处理器实际上可能有点用处，除非遇到基于 `Reactive Streams` 的 API，该 API 需要传递订阅者，而不是公开发布者。
>
> &emsp;&emsp;水槽(`Sinks`)通常是更好的选择。

&emsp;&emsp;`Sinks` 构建器为主要支持的生产者类型提供了一个引导式 `API`。您会发现 `Flux` 中的一些行为，例如 `onBackpressureBuffer`。

```java
Sinks.Many<Integer> replaySink = Sinks.many().replay().all();
```

&emsp;&emsp;多个生产者线程可以通过执行以下操作并发地在接收器上生成数据：

```java
//thread1
replaySink.emitNext(1, EmitFailureHandler.FAIL_FAST);

//thread2, later
replaySink.emitNext(2, EmitFailureHandler.FAIL_FAST);

//thread3, concurrently with thread 2
//would retry emitting for 2 seconds and fail with EmissionException if unsuccessful
replaySink.emitNext(3, EmitFailureHandler.busyLooping(Duration.ofSeconds(2)));

//thread3, concurrently with thread 2
//would return FAIL_NON_SERIALIZED
EmitResult result = replaySink.tryEmitNext(4);
```

> 使用 busyLooping 时，请注意返回的 EmitFailureHandler 实例不能重复使用，例如，它应该是每个 emitNext 调用一次 busyLooping。此外，建议使用 100 毫秒以上的超时，因为较小的值没有实际意义。